## Channels 

ðŸ‘‰ A channel is, in fact, a typed message queue: data can be transmitted through it. 
   It is a First In First Out (FIFO) structure, 
   and so it **preserves** the order of the items that are sent into it (for those who are familiar with it, a channel can be compared to a two-way pipe in Unix shells).

ðŸ‘‰ The value of an uninitialized channel is nil.

ðŸ‘‰ Data is passed around on channels: only one goroutine has access to a data item at any given time: so data races cannot occur, by design.
   The ownership of the data (that is the ability to read and write it) is passed around. A useful analogy is to compare a channel with a conveyor belt in a factory. 
   One machine (the producer goroutine) puts items onto the belt, and another machine (the consumer goroutine) takes them off for packaging.

ðŸ‘‰ A channel is also a reference type, so we have to use the make() function to allocate memory for it. Here is a declaration of a channel ch1 of strings, followed by its creation (instantiation):

```golang
var ch1 chan string
ch1 = make(chan string)
```

But of course, this can be shortened to:

```
ch1 := make(chan string)
```

### Communication operator

```golang
package main
import (
  "fmt"
  "time"
)

func main() {
  ch := make(chan string)
  go sendData(ch) // calling goroutine to send the data
  go getData(ch)  // calling goroutine to receive the data
  time.Sleep(1e9)  
}

func sendData(ch chan string) { // sending data to ch channel
  ch <- "Washington"
  ch <- "Tripoli"
  ch <- "London"
  ch <- "Beijing"
  ch <- "Tokyo"
}

func getData(ch chan string) {
  var input string
  for {
    input = <-ch // receiving data sent to ch channel
    fmt.Printf("%s ", input)
  }
  close(ch) // closed the channel
}
```
Here, we see that synchronization between the goroutines becomes important:

- The main() waits for 1 second so that both goroutines can come to completion. If this is not allowed, sendData() doesnâ€™t have the chance to produce its output.
- getData() works with an infinite for-loop. This comes to an end when sendData() has finished, and ch is empty.
- If we remove one or all go keywords, the program doesnâ€™t work anymore, and the Go runtime throws a panic:

---- Error run <path> with code Crashed Fatal error: all goroutines are asleep - deadlock!

