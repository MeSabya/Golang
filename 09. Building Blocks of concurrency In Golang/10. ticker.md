A Ticker in Go is used to perform an action repeatedly at fixed intervals — 
sort of like setInterval() in JavaScript, or a periodic timer in other languages.

```go
ticker := time.NewTicker(5 * time.Second)
defer ticker.Stop()
```
It gives you a channel (ticker.C) that delivers a timestamp every 5 seconds.

Each time you receive from ticker.C, you can trigger your periodic logic.

### Example-1

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ticker := time.NewTicker(1 * time.Second)
    done := make(chan bool)

    go func() {
        time.Sleep(5 * time.Second)
        done <- true
    }()

    for {
        select {
        case <-done:
            fmt.Println("Stopping ticker")
            ticker.Stop()
            return
        case t := <-ticker.C:
            fmt.Println("Tick at", t)
        }
    }
}
```

### Example 2: Periodic Flush in Go

Here’s a simple Golang example using a time.Ticker to periodically flush an in-memory buffer to disk or database.

```golang
package main

import (
	"fmt"
	"sync"
	"time"
)

// Shared buffer
type Buffer struct {
	data []string
	mu   sync.Mutex
}

// Add new data to buffer
func (b *Buffer) Add(item string) {
	b.mu.Lock()
	defer b.mu.Unlock()
	b.data = append(b.data, item)
}

// Flush buffer (simulate writing to DB)
func (b *Buffer) Flush() {
	b.mu.Lock()
	defer b.mu.Unlock()

	if len(b.data) == 0 {
		return
	}

	fmt.Printf("[%s] Flushing %d items to DB: %v\n",
		time.Now().Format("15:04:05"), len(b.data), b.data)

	// simulate DB write
	b.data = nil // clear buffer
}

func main() {
	buf := &Buffer{}
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	// Background flusher
	go func() {
		for range ticker.C {
			buf.Flush()
		}
	}()

	// Simulate incoming data
	for i := 0; i < 20; i++ {
		buf.Add(fmt.Sprintf("event-%d", i))
		time.Sleep(time.Duration(700) * time.Millisecond) // simulate arrival
	}

	fmt.Println("All events processed, waiting for final flush...")
	time.Sleep(6 * time.Second)
}
```

#### why lock is needed ... here multiple go routines are not involved?

Even though in the simple example above we don’t have explicit multiple goroutines writing to the buffer at the same time, we do have potential concurrency between two goroutines:

- Main goroutine → calling buf.Add()
  (simulating incoming data in a loop)
- Flusher goroutine → running in background via:
