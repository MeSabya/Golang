## Understanding Mutex Internals
The Structure (as of Go 1.20+)

```go
type Mutex struct {
    state int32
    sema  uint32
}
```

state is a bitfield used for:
- Locked flag (mutexLocked)
- Woken flag (mutexWoken)
- Waiter count (mutexWaiterShift)
- sema is a token used with the runtime semaphore (i.e., goroutine parking).

### What Happens in Lock()?
#### Fast Path (No contention):

- Tries to acquire the lock via CAS(state, 0, mutexLocked).
- If successful, done âœ….

#### Slow Path (Contention):
- Another goroutine has the lock.
- Increments waiter count.
- The calling goroutine spins briefly (uses CPU).
- If not acquired, goroutine sleeps (blocked on semaphore).

### Unlock() Flow:
- Atomically sets state to 0 (releases lock).
- If there are waiters, it wakes one goroutine by releasing the semaphore.

```shell
Goroutine 1: â”€â”€Lock()â”€â”€â–º [Lock Acquired]
Goroutine 2: â”€â”€Lock()â”€â”€â–º [Spins a bit] â”€â”€â–º [Sleeps]
Goroutine 1: â”€â”€Unlock()â”€â”€â–º [G2 Woken up via sema]
```

So the Mutex struct includes a state variable, which represents the lock's state, and a sema variable, which is a semaphore used for blocking and waking up goroutines.

### What Happens in Mutex Internals?
Hereâ€™s the simplified idea:

âœ… Lock (Fast path):

```go
if atomic.CompareAndSwapInt32(&mutex.state, 0, locked) {
    // Lock acquired, fast path
    return
}
```

#### ðŸ’¤ Lock (Slow path):
```go
// Increment waiter count
runtime_Semacquire(&mutex.sema) // Block here
This parks the goroutine efficiently until someone wakes it.
```

#### ðŸ”“ Unlock:

```go
// Release the lock
atomic.StoreInt32(&mutex.state, 0)
// Wake up waiter
runtime_Semrelease(&mutex.sema) // Wake up one goroutine
```

#### Goroutine Life Cycle with Semaphores
```text
Goroutine â”€â”€â–º Lock Contended â”€â”€â–º runtime_Semacquire â”€â”€â–º parked (waiting)
                        â”‚
                   Unlock() â”€â”€â–º runtime_Semrelease â”€â”€â–º scheduled again
```
