# Go's garbage collector 

Golang GC is a concurrent, tri-color mark-and-sweep collector. Here's a simplified breakdown of how it works:

- Mark Phase:
  The garbage collector identifies which objects are still in use by 'marking' them. It does this by scanning the stack, globals, and heap to see what memory is being referenced.
  If an object is referenced, it's considered reachable and hence marked as in use.

- Sweep Phase: Once all reachable objects are marked, the collector then 'sweeps' through the memory, freeing up space occupied by unmarked objects â€” those that are no longer reachable by the application.

- Concurrent and Non-blocking: One of the strengths of Go's garbage collector is that it runs concurrently with the program and aims to be non-blocking. This means that it does its job without pausing the program execution for long periods, which is a common drawback in garbage-collected languages.

## understanding roots, reachable, and unreachable objects

Imagine your program memory as a graph of objects connected by pointers (or references). Some of these objects are directly used by your program â€” we call these roots.

### ðŸŸ¢ Root Object
These are entry points into your object graph.

- Examples: global variables, local variables on the stack, function parameters.
- The garbage collector always starts from these.

### ðŸŸ¡ Reachable Object
- Any object that is directly or indirectly referenced from a root.
- These are still needed by your program.

### ðŸ”´ Unreachable Object
- An object that cannot be reached from any root.
- Itâ€™s "orphaned" in memory â€” no one is pointing to it.
- This is what the GC can safely delete.

### ðŸ’¡ Example
```go
heap := NewHeap()

a := heap.Allocate()       // Object A
b := heap.Allocate()       // Object B
c := heap.Allocate(a)      // Object C references A
d := heap.Allocate(b)      // Object D references B
e := heap.Allocate()       // Object E is standalone
```

Now letâ€™s define roots:

```go
roots := []*Object{c, d}
```

```Graph:
roots â†’ c â†’ a
       â†’ d â†’ b
       (e is not reachable)
```
c and d are roots

a and b are reachable (because c â†’ a, and d â†’ b)

e is unreachable (no one points to e)

### ðŸ”„ What GC Does:
- Mark Phase: GC starts at roots (c, d), marks c, d, then follows their pointers to a and b, marking them too.
- Sweep Phase: GC scans all objects (a, b, c, d, e). Since e is not marked, it gets deleted.

## Simple Go Gc

```
package main

import (
	"fmt"
	"sync"
)

type Object struct {
	marked bool
	refs   []*Object
}

type Heap struct {
	objects []*Object
	lock    sync.Mutex
}

func NewHeap() *Heap {
	return &Heap{
		objects: []*Object{},
	}
}

func (h *Heap) Allocate(refs ...*Object) *Object {
	h.lock.Lock()
	defer h.lock.Unlock()

	obj := &Object{marked: false, refs: refs}
	h.objects = append(h.objects, obj)
	return obj
}

func (h *Heap) Mark(root *Object) {
	if root == nil || root.marked {
		return
	}
	root.marked = true
	for _, ref := range root.refs {
		h.Mark(ref)
	}
}

func (h *Heap) Sweep() {
	h.lock.Lock()
	defer h.lock.Unlock()

	alive := []*Object{}
	for _, obj := range h.objects {
		if obj.marked {
			obj.marked = false // reset for next cycle
			alive = append(alive, obj)
		}
	}
	h.objects = alive
}

func (h *Heap) GC(roots []*Object) {
	for _, root := range roots {
		h.Mark(root)
	}
	h.Sweep()
}

func main() {
	heap := NewHeap()

	// Simulate object graph
	a := heap.Allocate()
	b := heap.Allocate()
	c := heap.Allocate(a)
	d := heap.Allocate(b)
	e := heap.Allocate()

	roots := []*Object{c, d} // a and b reachable, e is garbage

	fmt.Println("Before GC:", len(heap.objects)) // 5
	heap.GC(roots)
	fmt.Println("After GC:", len(heap.objects))  // 4
}
```
