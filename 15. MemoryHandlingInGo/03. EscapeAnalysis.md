# What Is Escape Analysis in Go?

Escape analysis is a compiler optimization technique that determines whether a variable can be safely allocated on the stack, or if it "escapes" to the heap and must be managed by the garbage collector (GC).

To see escape behavior:

```bash
go run -gcflags="-m" main.go
```
## Example 1: Pointer returned from function (escapes)
```go
func newInt() *int {
    x := 42
    return &x
}
```
### 🔍 Why it escapes:
- x is a local variable, but you're returning its address.
- So, x must live beyond the function, and is allocated on the heap.


## ✅ Example 2: Pointer used only within function (does not escape)
```go
func localPointer() {
    x := 42
    p := &x
    fmt.Println(*p)
}
```
### 🔍 Why it does NOT escape:
p is never returned or stored globally.

Compiler proves it’s safe to allocate on the stack.

## ✅ Example 3: Struct passed by value vs by pointer
go
Copy
Edit
type Data struct {
    x, y int
}

func valueParam(d Data) {
    fmt.Println(d.x + d.y)
}

func pointerParam(d *Data) {
    fmt.Println(d.x + d.y)
}
🔍 Escape depends on the caller:
go**/*-*********-***-
Copy
Edit
func main() {
    d := Data{1, 2}
    valueParam(d)   // no escape, copy of d passed
    pointerParam(&d) // d escapes because we take its address
}
css
Copy
Edit
d escapes to heap

## ✅ Example 4: Slice of pointers (heap) vs slice of values (stack)
go
Copy
Edit
func makeSlicePtrs() []*int {
    a, b := 1, 2
    return []*int{&a, &b}
}
🔍 a and b escape: their addresses are returned.

go
Copy
Edit
func makeSliceVals() []int {
    a, b := 1, 2
    return []int{a, b}
}
🔍 No escape here: values are copied.

## ✅ Example 5: Interface causes escape
go
Copy
Edit
func useInterface(i interface{}) {
    fmt.Println(i)
}

func main() {
    x := 42
    useInterface(x)
}
🔍 x escapes:

When passed to interface{}, it must be boxed, and Go often allocates boxed values on the heap.

## ✅ Example 6: Channel + Goroutines may cause escape
go
Copy
Edit
func main() {
    ch := make(chan *int)
    go func() {
        x := 42
        ch <- &x
    }()
    fmt.Println(<-ch)
}
🔍 x escapes:

It lives across a goroutine boundary. The Go runtime cannot prove when it will be read, so it goes to the heap.

## ✅ Example 7: Maps and escape
go
Copy
Edit
func makeMap() {
    x := 100
    m := make(map[string]*int)
    m["a"] = &x
}
🔍 x escapes:

Its address is stored in a heap-allocated map, so it must outlive the function scope.

✅ Summary Table
Code Pattern	Escape?	Why?
Returning address of local var	Yes	Must live beyond function
Local pointer used internally only	No	Stays in stack frame
Passing address to function	Yes	May be stored outside
Interface conversion	Yes	Causes boxing on heap
Goroutines and closures	Yes	Escapes stack frame to goroutine context
Struct passed by value	No	Copy; no reference escaping
Map with pointer value	Yes	Underlying map lives on heap


