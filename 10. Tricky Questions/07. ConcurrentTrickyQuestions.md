## Question1
```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan int, 1)
	c <- 1
	go func() {
		c <- 2
	}()
	fmt.Println(<-c)
	time.Sleep(time.Second)
}
```
### Answer
The code will print 1. The channel c is buffered with a size of 1, so the main goroutine can send 1 to the channel without blocking. 
The goroutine that sends 2 will block until the main goroutine reads the value 1 from the channel. 
Since 1 is read first, 2 is sent to the channel and will be available after the time.Sleep.

## Question2 

```golang
package main

import (
	"fmt"
	"time"
)

func worker(c chan int) {
	for {
		select {
		case n := <-c:
			fmt.Println("Received:", n)
		}
	}
}

func main() {
	c := make(chan int)
	go worker(c)

	time.Sleep(1 * time.Second)
	close(c)
}
```
### Answer 
The issue is that the goroutine created by worker will enter an infinite loop after the channel c is closed, leading to a goroutine leak. This happens because the select statement in the worker function does not handle the case when the channel is closed.

### Solution

```golang
package main

import (
	"fmt"
	"time"
)

func worker(c chan int) {
	for {
		select {
		case n, ok := <-c:
			if !ok {
				fmt.Println("Channel closed")
				return
			}
			fmt.Println("Received:", n)
		}
	}
}

func main() {
	c := make(chan int)
	go worker(c)

	time.Sleep(1 * time.Second)
	close(c)
}
```

## Question3 
What is the difference between the following codes:

```golang
for sum := range resultSum {
    result += sum
}
```
```golang
for i := 0; i < len(items); i++ {
    result += <-resultSum
}
```

### Answer
The range loop on a channel continues to receive values from the channel until the channel is closed.
Why It Needs Closing: If the channel is not closed, the loop will wait indefinitely for more values, causing a deadlock once all goroutines have finished sending data. 
This is because the loop does not have a condition to stop other than the channel being closed.

Second code snippet 
This loop iterates a fixed number of times, specifically the number of items being processed. It receives exactly len(items) values from the channel.
Why It Doesn't Need Closing: The loop knows exactly how many values it expects to receive (one for each item). Therefore, it will stop after receiving that many values, regardless of whether the channel is closed or not. The loop terminates after a predefined number of iterations, so it does not depend on the channel being closed to finish execution.





