## Question1
```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan int, 1)
	c <- 1
	go func() {
		c <- 2
	}()
	fmt.Println(<-c)
	time.Sleep(time.Second)
}
```
### Answer
The code will print 1. The channel c is buffered with a size of 1, so the main goroutine can send 1 to the channel without blocking. 
The goroutine that sends 2 will block until the main goroutine reads the value 1 from the channel. 
Since 1 is read first, 2 is sent to the channel and will be available after the time.Sleep.

## Question2 

```golang
package main

import (
	"fmt"
	"time"
)

func worker(c chan int) {
	for {
		select {
		case n := <-c:
			fmt.Println("Received:", n)
		}
	}
}

func main() {
	c := make(chan int)
	go worker(c)

	time.Sleep(1 * time.Second)
	close(c)
}
```
### Answer 
The issue is that the goroutine created by worker will enter an infinite loop after the channel c is closed, leading to a goroutine leak. This happens because the select statement in the worker function does not handle the case when the channel is closed.

### Solution

```golang
package main

import (
	"fmt"
	"time"
)

func worker(c chan int) {
	for {
		select {
		case n, ok := <-c:
			if !ok {
				fmt.Println("Channel closed")
				return
			}
			fmt.Println("Received:", n)
		}
	}
}

func main() {
	c := make(chan int)
	go worker(c)

	time.Sleep(1 * time.Second)
	close(c)
}
```

## Question3 
What is the difference between the following codes:

```golang
for sum := range resultSum {
    result += sum
}
```
```golang
for i := 0; i < len(items); i++ {
    result += <-resultSum
}
```

### Answer
The range loop on a channel continues to receive values from the channel until the channel is closed.
Why It Needs Closing: If the channel is not closed, the loop will wait indefinitely for more values, causing a deadlock once all goroutines have finished sending data. 
This is because the loop does not have a condition to stop other than the channel being closed.

Second code snippet 
This loop iterates a fixed number of times, specifically the number of items being processed. It receives exactly len(items) values from the channel.
Why It Doesn't Need Closing: The loop knows exactly how many values it expects to receive (one for each item). Therefore, it will stop after receiving that many values, regardless of whether the channel is closed or not. The loop terminates after a predefined number of iterations, so it does not depend on the channel being closed to finish execution.

## Question4

```golang

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			if i == 3 {
				panic("something went wrong")
			}
			fmt.Println(i)
		}(i)
	}

	wg.Wait()
	fmt.Println("Done")
}
```

The expected output can vary due to the concurrent nature of goroutines. However, the following points are important:

Normal Completion:

For i = 0, 1, 2, 4, the corresponding goroutines will print the value of i and then complete.
Panic Handling:

For i = 3, the goroutine will panic. The defer wg.Done() ensures that the WaitGroup counter is decremented even when a panic occurs.
Since the panic happens in a separate goroutine, it does not crash the main program. However, if you run this code in a way that shows stack traces (e.g., in a local Go environment), you would see a panic message.
Main Goroutine:

After all spawned goroutines complete (including the one that panicked), the wg.Wait() call will return.
Finally, "Done" is printed.

## Question 5 

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	ch := make(chan int)

	wg.Add(1)
	go func() {
		defer wg.Done()
		ch <- 42
	}()
	wg.Wait()
        fmt.Println(<-ch)
}
```

#### What's Wrong?
wg.Wait() Blocks Forever

- The goroutine is sending a value (ch <- 42) to the channel.But the main goroutine is waiting (wg.Wait()) before reading from the channel (<-ch).
- Since the channel is unbuffered, the send blocks until another goroutine reads from it.
- But the main goroutine is blocked on wg.Wait() and never reaches the fmt.Println(<-ch) line.
- Result: DEADLOCK ‚ùå

## Question 6

```golang
func main() {
    var wg sync.WaitGroup

    // It's not easy to reproduce concurrency issues, so we loop multiple times
    for i := 0; i < 100000; i++ {
        go addDoneFunc(&wg)
        go waitFunc(&wg)
    }

    wg.Wait()
}

func addDoneFunc(wg *sync.WaitGroup) {
    wg.Add(1)
    wg.Done()
}

func waitFunc(wg *sync.WaitGroup) {
    wg.Wait()
}
```
calling wg.Add(1) and wg.Done() in one goroutine, and wg.Wait() in another goroutine, without any synchronization between them.

In Go's sync.WaitGroup, calling Wait() while another goroutine is calling Add() is not safe unless:

***You ensure all calls to Add() complete before any call to Wait(), or
You protect Add/Done and Wait using another synchronization mechanism (e.g., a channel, mutex, etc.)
From the Go documentation:
"Calls to Add must happen before the call to Wait, or else Wait may wait forever."
"It is not safe to call Add and Wait concurrently."***

#### Output:
wg.Wait() runs before wg.Add(1) ‚Üí undefined behavior or panic like:
panic: sync: WaitGroup is reused before previous Wait has returned

#### Reason:
- go addDoneFunc(&wg) --> It is calling Add()
- go waitFunc(&wg) --> wg.Wait()
go scheduler can schedule these go routines in any order, so potentially waitFunc() may be called before addDoneFunc() which is violating the above golang
documentation.

## Question: 7

What Happens If wg.Done() Is Called More Times Than wg.Add()?
‚û°Ô∏è Panic at runtime:

```txt
panic: sync: negative WaitGroup counter
```

üîç Why?
The internal counter of a WaitGroup starts at 0.

- Every Add(n) increases the counter by n.
- Every Done() decreases the counter by 1.
- Calling Done() more times than Add() leads the counter to go negative, which is not allowed, and causes a panic.





