## Understanding the append Function 

```golang
package main
import "fmt"

func main() {
    arr := []int{1, 2, 3}
    fmt.Println("Len of arr", len(arr))
    fmt.Println("Cap of arr", cap(arr))
    
    arr1 := arr[:1]
    fmt.Println("arr and arr1", arr, arr1)
    fmt.Println("Len of arr1", len(arr1))
    fmt.Println("Cap of arr1", cap(arr1))
    
    arr1 = append(arr1, 5)
    fmt.Println("arr and arr1", arr, arr1)
    fmt.Println("Len of arr1", len(arr1))
    fmt.Println("Cap of arr1", cap(arr1))
       
    arr1 = append(arr1, 6)
    fmt.Println("arr and arr1", arr, arr1)
    fmt.Println("Len of arr1", len(arr1))
    fmt.Println("Cap of arr1", cap(arr1))
    fmt.Println("Cap of arr", cap(arr))
    
    arr1 = append(arr1, 7)
    fmt.Println("arr and arr1", arr, arr1)
    fmt.Println("Len of arr1", len(arr1))
    fmt.Println("Cap of arr1", cap(arr1))
    fmt.Println("Cap of arr", cap(arr))
}
```

```bash
Len of arr 3
Cap of arr 3
arr and arr1 [1 2 3] [1]
Len of arr1 1
Cap of arr1 3
arr and arr1 [1 5 3] [1 5]
Len of arr1 2
Cap of arr1 3
arr and arr1 [1 5 6] [1 5 6]
Len of arr1 3
Cap of arr1 3
Cap of arr 3
arr and arr1 [1 5 6] [1 5 6 7]
Len of arr1 4
Cap of arr1 6
Cap of arr 3
```

### Explanation
Initial Slice:

arr is a slice with elements {1, 2, 3}.
The length of arr is 3, and the capacity is also 3.
Slice arr1 Created:

arr1 := arr[:1] creates a new slice arr1 that includes the first element of arr (resulting in {1}).
The length of arr1 is 1, and the capacity is still 3.
Append Element to arr1:

arr1 = append(arr1, 5) appends 5 to arr1.
The length of arr1 becomes 2, and the capacity remains 3.
Now, arr1 contains {1, 5}.
Append Another Element to arr1:

arr1 = append(arr1, 6) appends 6 to arr1.
The length of arr1 becomes 3, and the capacity remains 3.
Now, arr1 contains {1, 5, 6}.
Append Yet Another Element to arr1:

arr1 = append(arr1, 7) appends 7 to arr1.
Since the capacity of arr1 is not sufficient, Go automatically increases the capacity by allocating a new underlying array, copying the existing elements, and appending the new element.
The length of arr1 becomes 4, and the new capacity becomes 6 (as Go often doubles the capacity).
Now, arr1 contains {1, 5, 6, 7}.

Print the Final Output:

The last set of Println statements shows the state of both arr and arr1.
**The capacity of arr remains 3 throughout these operations, and the capacity of arr1 increases dynamically as needed.**
In summary, when appending elements to a slice, Go dynamically manages the capacity by reallocating the underlying array as necessary. The growth factor is often implementation-dependent, but it's common for Go to double the capacity to achieve amortized constant-time complexity for append operations.

## Understand the last point on capacity and new array allocation

```golang
package main

import "fmt"

func main() {
    slice := []int{1, 2, 3}
    fmt.Println("Original Slice:", slice)
    fmt.Println("Original Capacity:", cap(slice))

    // Append elements that exceed the capacity
    slice1 := append(slice, 4, 5, 6, 7)

    fmt.Println("Original Slice:", slice)
    fmt.Println("Original Capacity:", cap(slice))
    fmt.Println("Updated Slice:", slice1)
    fmt.Println("Updated Capacity:", cap(slice1))
}
```










