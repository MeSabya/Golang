## Example: Adding Custom Middleware in Gin

```go
package main

import (
	"log"
	"time"

	"github.com/gin-gonic/gin"
)

// Custom middleware to log requests
func requestLogger() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Record the start time
		startTime := time.Now()

		// Process the request
		c.Next()

		// Log details after the request is processed
		duration := time.Since(startTime)
		method := c.Request.Method
		path := c.Request.URL.Path
		status := c.Writer.Status()

		log.Printf("[INFO] %s %s - %d (%s)", method, path, status, duration)
	}
}

func main() {
	router := gin.Default()

	// Apply the middleware globally
	router.Use(requestLogger())

	// Define a simple route
	router.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{"message": "pong"})
	})

	// Start the server
	router.Run(":8080")
}
```

### Detailed Flow Diagram

Request -> [RequestLogger Middleware (Before)] -> [Route Handler] -> [RequestLogger Middleware (After)] -> Response

#### Key Points in the Flow:
- c.Next(): This is a crucial call. It tells Gin to continue to the next middleware or route handler. The requestLogger logs the "before" data (start time), and then after the route handler finishes, it logs the "after" data (duration, status code).
- Asynchronous Processing: If you use c.Next() and have other middleware (e.g., for handling things like authentication or validation), they execute in the order they are defined, and the logger middleware runs after those to capture the final response status.
